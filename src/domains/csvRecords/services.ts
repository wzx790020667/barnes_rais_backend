import { isEmpty, uniqueId } from "lodash";
import type { CsvRecord, Document, DocumentItem } from "../../db/schema";
import { supabase, db, drizzleDb } from "../../lib";
import { randomUUIDv7 } from "bun";
import { eq } from "drizzle-orm";
import { csv_records } from "../../db/schema";

export class CsvRecordService {
    async createCsvRecords(document: Document) {
        const documentType = document.document_type;

        const importDocumentWithItems = await db.query(async () => {
            const {data, error} = await supabase.from("documents")
                .select("*, document_items(*)")
                .eq("import_number", document.import_number)
                .eq("document_type", "import_declaration")
                .single();

            if (error) throw error;

            return {
                document: data as Document,
                items: (data?.document_items || []) as DocumentItem[]
            };
        }).then(result => result.data || null);

        // Track how many times each part number has been searched
        const partNumberSearchCounts: Record<string, number> = {};

        const findImportPriceByPartNumber = (partNumber: string | null) => {
            if (!partNumber) return null;
            
            const importItems = importDocumentWithItems?.items;
            if (!importItems || importItems.length === 0) return null;
            
            // Filter all matching items for this part number
            const matchingItems = importItems.filter(item => item.part_number === partNumber);
            if (matchingItems.length === 0) return null;
            
            // Get current search count and increment for next search
            partNumberSearchCounts[partNumber] = (partNumberSearchCounts[partNumber] || 0) + 1;
            const currentSearchCount = partNumberSearchCounts[partNumber];
            
            // Get the index based on search count (1-indexed to 0-indexed)
            const index = Math.min(currentSearchCount - 1, matchingItems.length - 1);
            
            // Return the import price of the selected item
            return matchingItems[index]?.import_price || null;
        }

        const documentWithItems = await db.query(async () => {
            // Fetch the document with its associated items in a single query
            const { data, error } = await supabase
                .from("documents")
                .select(`
                    *,
                    document_items(*)
                `)
                .eq("id", document.id)
                .single();

            if (error) throw error;

            return {
                document: data as Document,
                items: (data?.document_items || []) as DocumentItem[]
            };
        }).then(result => result.data || { document: document, items: [] });

        let records: Omit<CsvRecord, "id" | "created_at">[] = [];

        documentWithItems.items.forEach(item => {
            // Helper function to safely convert timestamp to Date or null
            const toDateOrNull = (timestamp: string | Date | null | undefined): Date | null => {
                if (!timestamp) return null;
                return timestamp instanceof Date ? timestamp : new Date(timestamp);
            };

            const record: Omit<CsvRecord, "id" | "created_at"> = {
                document_id: documentWithItems.document.id,
                batch_number: null,
                import_doc_num: documentWithItems.document.import_number || null,
                IMPORT_LINE: "<auto-generated>",
                cust_po: documentWithItems.document.po_number,
                CO_PREFIX: null,
                PRODUCT_CODE: null,
                CUST_CODE: documentWithItems.document.co_code,
                CUST_NAME: importDocumentWithItems?.document.customer_name || null,
                item: item.part_number,
                ser_num: item.serial_number,
                import_price: findImportPriceByPartNumber(item.part_number),
                qty_ordered: item.quantity_ordered,
                engine_model: item.engine_model,
                engine_num: item.engine_number,
                cust_num: null,
                end_user_cust_name: documentWithItems.document.end_user_customer_name,
                WORK_SCOPE: documentWithItems.document.work_scope,
                cert_num: documentWithItems.document.arc_requirement,
                order_date: documentType === "import_declaration" ? toDateOrNull(documentWithItems.document.scanned_time) : null,
                part_rcvd_date: documentType === "purchase_order" ? toDateOrNull(documentWithItems.document.scanned_time) : null,
                CSN_NUMBER: documentWithItems.document.csn,
                TSN_NUMBER: documentWithItems.document.tsn,
            }
            records.push(record);
        })
        // Use Drizzle transaction to handle both operations atomically
        await db.query(async () => {
            try {
                // Execute both operations in a transaction using the centralized Drizzle instance
                return await drizzleDb.transaction(async (tx) => {
                    // Delete existing records
                    await tx.delete(csv_records).where(eq(csv_records.document_id, documentWithItems.document.id));
                    
                    // Insert new records
                    if (records.length > 0) {
                        await tx.insert(csv_records).values(records);
                    }
                    
                    return { success: true };
                });
            } catch (error) {
                console.error("Transaction failed:", error);
                throw error;
            }
        });
    }

    async getCsvRecordsOfNoBatchNumber(documentIds?: string[]) {
        const query = supabase.from("csv_records")
            .select(`
                import_doc_num, IMPORT_LINE, cust_po, CO_PREFIX, 
                PRODUCT_CODE, CUST_CODE, CUST_NAME, item, ser_num, 
                import_price, qty_ordered, engine_model, engine_num, 
                cust_num, end_user_cust_name, WORK_SCOPE, cert_num, 
                order_date, part_rcvd_date, CSN_NUMBER, TSN_NUMBER
            `)
            .is("batch_number", null);            
        // If document IDs are provided, filter by them
        if (documentIds && documentIds.length > 0) {
            query.in("document_id", documentIds);
        }
        
        const {data, error} = await query;

        if (error) throw error;

        return data as CsvRecord[];
    }

    async markAsExported(csvRecords: CsvRecord[]) {
        if (csvRecords.length === 0) return;
        
        // Generate a single batch number for all records in this export
        const batchNumber = randomUUIDv7();
        
        // Update all records with the new batch number
        const recordIds = csvRecords.map(record => record.id);
        
        const { error } = await supabase
            .from("csv_records")
            .update({ batch_number: batchNumber })
            .in("id", recordIds);
            
        if (error) throw error;
        
        return batchNumber;
    }
}